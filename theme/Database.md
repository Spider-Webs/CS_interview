<h2>데이터베이스 기술 면접</h2>
<hr>
<ol>
  <h5><a href="#zero"><li>데이터베이스 풀 에대해 설명해주세요</li></a></h5>
  <h5><a href="#one"><li>트리거에 대해 설명해주세요 </li></a></h5>
  <h5><a href="#two"><li>인덱스(Index) 대해 설명해주세요 </li></a></h5>
  <h5><a href="#three"><li>SQL Injection이 무엇인지 설명해주세요. </li></a></h5>
  <h5><a href="#four"><li>이상 현상(Anomaly)이란? </li></a></h5>
  <h5><a href="#five"><li>정규화란? </li></a></h5>
  <h5><a href="#six"><li> RDBMS와 NoSQL의 차이에 대해 설명해주세요. </li></a></h5>
  <h5><a href="#seven"><li> 옵티마이저(Optimizer)에 대해 아는대로 말해주세요. </li></a></h5>
  <h5><a href="#eight"><li> ORM에대해 설명해주세요 </li></a></h5>
</ol>

<br><br>

<hr>
<a name="zero"><b>0. 데이터베이스 풀 에대해 설명해주세요.</b></a>
<hr>
<ul>
  <li>
    <h5>Connection Pool</h5>
    <ul>
      <li>클라이언트의 요청에 따라 각 어플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 Connection이 필요하다.</li>
      <li>데이터베이스와 Connection한 객체들을 미리 생성해 Pool에 저장해두었다가, 클라이언트의 요청이 들어올 때마다 사용/반환하는 방식</li>
    </ul>
  </li>  
  <li>
    DB에 접근하는 단계
    <ol>
      <li>웹 컨테이너가 실행되면서 DB와 연결된 Connection 객체들을 미리 생성하여 pool에 저장한다.</li>
      <li>DB에 요청 시, pool에서 Connection 객체를 가져와 DB에 접근한다.</li>
      <li>처리가 끝나면 다시 pool에 반환한다.</li>
    </ol>  
  </li>
  <li>
     Connection이 부족할 경우
    <ul>
      <li> 모든 Connection이 요청을 처리 중일 때, 해당 클라이언트의 요청을 대기 상태로 전환</li>
      <li>  Pool에 Connection 객체가 반환되면 순차적으로 요청을 처리</li>
    </ul>  
  </li>
  
  <li>
    장점
    <ul>
      <li>매 연결마다 Connection 객체를 생성/제거하는 비용 감소</li>
      <li>미리 생성된 Connection 객체를 사용하므로 데이터베이스 접근 시간 단축</li>
      <li>Connection 수를 제한해 부하 조정</li>
    </ul>  
  </li>
  
  <li>
    단점
    <ul>
      <li>Connection 또한 객체이므로 메모리 차지</li>
      <li>Connection 개수를 잘 못 설정할 경우, 쓸모없는 Connection이 발생할 수 있음</li>
    </ul>  
  </li>
  
  <li>
    Thread Pool
    <ul>
      <li>비슷한 맥락으로 Thread pool이라는 개념도 있다.</li>
      <li>이 역시 매 요청마다 요청을 처리할 Thread를 만드는것이 아닌, 미리 생성한 pool 내의 Thread를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법.</li>
    </ul>
  </li>
  
  <li>
    Thread Pool과 Connection pool
    <ul>
      <li>WAS에서 Thread pool과 Connection pool내의 Thread와 Connection의 수는 직접적으로 메모리와 관련이 있기 때문에, 많이 사용하면 할 수록 메모리를 많이 점유하게 된다. 그렇다고 반대로 메모리를 위해 적게 지정한다면, 서버에서는 많은 요청을 처리하지 못하고 대기 할 수 밖에 없다.</li>
      <li>보통 WAS의 Thread의 수가 Conncetion의 수보다 많은 것이 좋은데, 그 이유는 모든 요청이 DB에 접근하는 작업이 아니기 때문이다.</li>
    </ul>  
  </li>
</ul>  


<hr>
<a name="one"><b>1. 트리거(Trigger)에 대해 설명해주세요.</b></a>
<hr>
<ul>
  <li>트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다.</li>
  <li>사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 가장 큰 특징입니다.</li>
</ul>  

<hr>
<a name="two"><b>2.인덱스(Index)에 대해 설명해주세요.</b></a>
<hr>
<ul>
  <li><b>Index란?</b></li>
<pre>
Index란 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 
달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법입니다.

예를들어, DB를 책으로 비유하면 데이터는 책의 내용일 것이고, 데이터가 저장된 레코드의 주소는 index 목록에 있는 페이지 번호일 것이다.

인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠르지만, 
새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.
즉, 인덱스는 데이터의 저장 성능을 희생하고 그대신 데이터의 검색 속도를 높이는 기능이라 할 수 있습니다.
</pre>

  <li><b>그렇다면 DBMS는 Index를 어떻게 관리하고 있나요? (Index 자료구조)</b></li>
  <pre>
B+Tree 인덱스 자료구조
자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이며,
BTree 리프노드(자식노드가 없는 노드)들을 LinkedList로 연결하여 순차 검색을 용이하게 합니다. 
해시 테이블보다 나쁜 O(log2N)의 시간복잡도를 갖지만 일반적으로 사용되는 자료구조입니다.
<br>

해시 테이블
컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현합니다.
시간복잡도가 O(1)이라 검색이 매우 빠릅니다.
부등호(<,>)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하기 때문에 사용에 적합하지 않습니다.

  </pre>
</ul>
  
<hr>
<a name="three"><b>3. SQL Injection이 무엇인지 설명해주세요..</b></a>
<hr>
<pre>
<h4>SQL Injection이란</h4>
공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법입니다.
<br>
<h4>SQL Injection을 방어 및 방지하기 위한 방법에 대해 알고 있다면 설명해주세요</h4><ol>
<li> 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값) 인지 검증합니다.</li>
<li> 저장 프로시저를 사용합니다.
※ 저장 프로시저란 사용하고자 하는 Query에 미리 형식을 지정하는 것을 말한다. 
지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상한다.</li>
</ol>
</pre>
  
<hr>
<a name="four"><b>4.이상 현상(Anomaly)이란?</b></a>
<hr>
<p>
이상 현상은 테이블을 설계할 때 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 논리적으로 생기는 오류를 말합니다.
이상 현상은 갱신 이상(Modification ANomaly), 삽입 이상(Insertion Anomaly), 삭제 이상(Deletion Anomaly)으로 구성됩니다.
</p>
  <br>
<ol>
  <li><b>삽입 이상 : 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상</b></li>
  <li><b>갱신 이상 : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상</b></li>
  <li><b> 삭제 이상 : 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상</b></li>
</ol>
<br>
<p>
  이러한 이상 현상을 예방하고 효과적인 연산을 하기 위해 데이터 정규화(Data Normalication) 를 합니다.
</p>

<hr>
<a name="five"><b>5.정규화란?</b></a>
<hr>
<ul>
  <li>
    정규화란?
  <p>
  하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며,
  데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법입니다.<br>
    ※릴레이션이란 관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위이다. 결국, 릴레이션은 DB 테이블이다
  </p>
  </li>  
  <li>
    정규화의 목적
    <pre>
다양한 목적이 있지만, 대표적으로 두 가지가 있습니다.
첫째, 불필요한 데이터 (data redundancy)를 제거해 불필요한 중복을 최소화한다.
하나의 테이블에 모든 정보를 다 넣게 된다면, 동일한 정보들이 불필요하게 중복되어 저장될 수 있습니다.
둘째, 삽입/갱신/삭제 시 발생할 수 있는 각종 이상 현상(Anomaly)을 방지하기 위해서, 
테이블의 구성을 논리적이고 직관적으로 한다.
그 외에 DB 구조 확장 시 재디자인을 최소화, 다양한 관점에서의 query를 지원하기 위해서 등등의 목적이 있습니다.
    </pre>
  </li>
  <li>
    정규화과정
    <pre>
[ 제1 정규화 ]
제1 정규화란 테이블의 칼럼이 원자 값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것입니다.
    <br>
[ 제2 정규화 ]
제2 정규화란 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것입니다.
여기서 완전 함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미합니다.
<br>
[ 제 3 정규화 ]
제3 정규화란 제2 정규화를 진행한 테이블에 대해 이행적 함수 종속을 없애도록 테이블을 분해하는 것입니다.
여기서 이행적 함수 종속은 A → B , B → C가 성립할 때 A → C가 성립되는 것을 의미합니다.
<br>
[ BCNF 정규화 ] 
BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것입니다.
    </pre>
  </li>
  
  <li>
    정규화에는 어떤 장점이 있고 어떤 단점이 있는지 아는대로 설명해주세요.
    <pre>
장점
1. 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.
2. 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
단점
릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다.
+ 정규화를 수행한다는 것은 이상현상을 제거하는 것이다. 
데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로
한 테이블의 데이터 용량이 최소화되는 효과가 있다. 
따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.
    </pre>
  </li>
  <li>
    역정규화를 하는 이유에 대해 아는대로 설명해주세요.
    <p>
 정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로인해 성능이 저하될 우려가 있습니다. 
역정규화를 하는 가장 큰 이유는 성능 문제가 있는(읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함입니다.
    </p>
  </li>
</ul>

<hr>
<a name="six"><b>6.RDBMS와 NoSQL의 차이에 대해 설명해주세요.</b></a>
<hr>
 <ul>
   <li>
     RDBMS는 모든 데이터를 2차원 테이블 형태로 표현합니다.
     <ul>
       <li>장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.</li>
       <li>단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)</li>
     </ul>
</li>
   <br>
   <li>
   NoSQL(Not Only SQL)은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다.
  <ul>
    <li>장점 : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.</li>
    <li>데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만아닌 scale-out 또한 가능하다.</li>
    <li>단점 : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.</li>
    <li>스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다. </li>
     </ul>
   </li>
    <br>
   <li> 그렇다면 RDBMS와 NoSQL은 어느 경우에 적합한가요?</li>
   <ul>
     <li>
      RDBMS는 데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋습니다. 또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다.
     </li>
     <li>
       NoSQL은 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋습니다. 또한 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋으며, Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 Scale-out 해야 되는 시스템에 적합합니다.
     </li>
   </ul>
  </ul>
  
  
 <hr>
<a name="seven"><b>7. 옵티마이저(Optimizer)에 대해 아는대로 말해주세요.</b></a>
<hr>
  <ul>
    <li>
      옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진입니다.
    </li>
    <br>
    <li>
      컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있습니다. 개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저라는 곳에서 “이 쿼리문을 어떻게 실행시키겠다!”라는 여러가지 실행 계획을 세우고, 최고의 효율을 갖는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행하게 되는 것입니다.
    </li>
  </ul>
  
<hr>
<a name="eight"><b>8. ORM에 대해 설명해주세요.</b></a>
<hr>
  <ul>
    <li>
      ORM 이란?
     <pre>
Object-Relational Mapping 즉, 객체와 관계형 데이터베이스 매핑의 줄임말입니다. 
우리가 OOP(Object Oriented Programming)에서 쓰는 객체라는 개념을 구현한 클래스와
RDB(Relational DataBase)에서 쓰이는 데이터인 테이블을 매핑(연결)하는 것을 의미합니다.
ORM을 이용하면 SQL Query가 아닌 직관적인 코드(메소드)로서 데이터를 조작할 수 있습니다.
예를들어, Member 테이블의 데이터를 출력하기 위해서 MySQL에서는 SELECT * FROM Member; 라는 query를 실행해야 하지만,
ORM을 사용하면 Member 테이블과 매핑된 객체를 member라 할 때, member.findAll(); 라는 메소드 호출로 데이터 조회가 가능합니다.
      </pre>
    </li>
    <li>
객체-관계 간의 불일치
      <pre>
      클래스와 테이블은 서로가 기존부터 호환가능성을 두고 만들어진 것은 아니기 때문에 아래와 같은 불일치가 발생하는데, 
이를 ORM을 통해 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하여 불일치를 해결합니다.
따라서 ORM을 이용하면 따로 SQL문을 작성할 필요 없이 객체를 통해 간접적으로 데이터베이스를 조작할 수 있게 됩니다.
      </pre>
    </li>
    <br>
    <li>
      장점
      <ul>
        <li>
          <b>객체지향적인 코드로 인해 더 직관적이고 로직에 집중할 수 있도록 도와준다.</b>
          <ul>
            <li>SQL문이 아닌 클래스의 메소드를 통해 DB를 조작할 수 있으므로 개발자가 객체 모델만 이용해서 개발을 하는 데 집중할 수 있다.</li>
            <li>선언문, 할당, 종료 같은 부수적인 코드가 없거나 줄어든다.</li>
            <li>객체마다 코드를 별도로 작성하기 때문에 코드의 가독성이 높아진다.</li>
            <li>SQL의 절차적이고 순차적인 접근이 아닌 객체지향적인 접근으로 인해 생산성을 높여준다.</li>  
          </ul>
        </li>
        <li>
          <b>재사용 및 유지보수의 편리성이 증가한다</b>
          <ul>
            <li>ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용할 수 있다.</li>
            <li>매핑 정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.</li>
          </ul>
        </li>
        <li>
          <b>DBMS(Database Management System)에 대한 종속성이 줄어든다</b>
          <ul>
            <li>대부분 ORM 솔루션은 DB에 종속적이지 않기 때문에 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다.</li>
            <li>개발자는 Object에 집중함으로 극단적으로 DBMS를 교체하는 큰 작업에도 적은 리스크와 시간이 소요된다.</li>
            <li>또한 자바에서 가공할 경우 equals , hashcode 의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.</li>
          </ul>
        </li>
      </ul>
    </li>
      <br>
    <li>
      단점
      <ul>
        <li>
          <b>완벽한 ORM으로만 서비스를 구현하기 어렵다</b>
          <ul>
            <li>사용하기는 편하지만 설계는 매우 신중하게 해야한다.</li>
            <li>프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.</li>
            <li>잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.</li>
            <li>일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는 등 별도의 튜닝이 필요한 경우가 있다</li>
          </ul>
        </li>
        <li>
          <b>프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다</b>
          <ul>
            <li>이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 발생할 수 있다.</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  
  
  
<hr>
<h2>참조</h2>
<h3><a href="https://www.youtube.com/channel/UCHFz--glnVVP1xBLA-8kltg">인큐티비 - 유튜브</a>
<h3><a href="https://dev-coco.tistory.com">슬기로운 개발 생활 - 블로그</a></h3>
<h3><a href="https://dheldh77.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%92%80Database-Pool">테리의 일상 - 블로그</a></h3>
