<h2>자바 기술 면접</h2>
<hr>
<ol>
<h5><a href="#zero"><li> 요청과 응답으로 엔티티(Entity) 대신 DTO를 사용하는 이유에 대해 설명해주세요 </li></a></h5>
<h5><a href="#one"><li> 빌더패턴에대해 설명해주세요 </li></a></h5>
</ol>

<hr>
<a name="zero"><b>0. 요청과 응답으로 엔티티(Entity) 대신 DTO를 사용하는 이유에 대해 설명해주세요 </b></a>
<hr>
<ol>
  <li><b>엔티티 내부를 캡슐화 할 수 있다.</b></li>
  <pre>
  엔티티란 도메인의 핵심 로직과 속성을 가지고 있고, 실제 DB의 테이블과 매칭되는 클래스이다.
  그렇기 때문에 엔티티가 getter와 setter를 갖게 된다면, 
  controller와 같은 비즈니스 로직과 크게 상관없는 곳에서 자원의소 속성이 실수로 변경될 수 있다. 
  또한 엔티티를 UI(User Interface)에서 노출하는 것은 테이블 설계를 화면에 공개하는 것이기에 보안상으로 좋치않다.
  그렇기에 데이터 전달 역할로 DTO를 사용해야한다.
  </pre>
  
  <li><b>화면에 필요한 데이터를 선별할 수 있다</b></li>
  <pre>
  애플리케이션이 확장되면 엔티티의 크기는 점차 커진다 이때 응답과 요청으로 엔티티를 사용한다면, 
  요청하는 화면에 필요하지않는 속성까지도 함께 보내진다. 
  모든 API 요청과 응답에서 엔티티의 모든 속성이 함께 전송되기 때문에 당연히 속도가 느려진다 
  </pre>
  
  <li><b>순환 참조를 예발할 수 있다</b></li>
  <pre>
  양방향 참조된 엔티티를 컨트롤러에서 응답으로 return하게 되면, 
  엔티티가 참조하고 있는 객체는 지연 로딩되고, 로딩된 객체는 또 다시 본인이 참조하고 있는 객체를 호출하게 된다. 
  이렇게 서로 참조하는 객체를 계속 호출하면서 무한 루프 문제가 발생된다
  이러한 경우 양방향 참조가 부득이한 상황이라면 순환참조가 일어나지 않도록 응답의 return으로 DTO로 두는 것이 더 안전하다
  </pre>
  
  <li><b>validation 코드와 모델링 코드를 분리할 수 있다</b></li>
  <pre>
  엔티티 클래스는 DB의 테이블과 매칭되는 필드과 속성으로 선언되어 있고, 
  복잡한 비즈니스 로직이 작성되어 있는 곳이다. 
  여기에 만약 validation 코드가 들어간다면 엔티티 클래스는 더 복잡해지고 가독성이 저하된다. 
  이러한 경우 validation을 DTO에서 정의한다면 엔티티 클래스를 좀 더 모델링과 비즈니스 로직에만 집중되도록 만들 수 
  </pre>
</ol>


<hr>
<a name="one"><b>1. 빌더패턴에대해 설명해주세요 </b></a>
<hr>
<pre>
Builder 패턴은 인스턴스를 생성할 때 생성자(Constructor)만을 통해서 생성하는데는 어려움이 있어서 고안된 패턴이다. 
정보들은 자바빈즈패턴처럼 받되, 데이터 일관성을 위해 정보들을 다 받은 후에 객체를 생성한다.
클래스에 생성자 인자가 많다면 Builder 패턴을 사용하면 좋다. 
왜냐하면 생성자 인자가 너무 많다면 어떠한 인자가 어떠한 값을 나타내는지 알기 어렵기 때문이다

<ul>
빌더패턴을 적용하면 다음과 같은 장점이 있다
<li>불필요한 생성자의 제거</li>
<li>데이터의 순서에 상관없이 객체생성 가능</li>
<li>명시적 선언으로 이해하기 쉽습니다</li>
<li>각 인자의 어떤 의미인지 알기 쉽다</li>
<li>setter 메서드가 없으므로 변경불가능한 객체를 만들 수 있다</li>
<li>한번에 객체를 생성하므로 객체 일관성이 깨지지 않는다</li>
<li>build()함수가 null 체크를 해준다</li>
</ul>
</pre>

※
<h6>자바 빈즈 패턴이란?</h6>
<p>
setter를 사용한 패턴으로 기존 생성자의 단점으로 가독성이 저하되는 문제를 해결하였지만, 
코드량이 늘어나며 가장 문제가되는 점이 객체의 불변성이 깨질 수 있다는 것이다
</p>
