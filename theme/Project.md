<h2>자바 기술 면접</h2>
<hr>
<ol>
<h5><a href="#zero"><li> 요청과 응답으로 엔티티(Entity) 대신 DTO를 사용하는 이유에 대해 설명해주세요 </li></a></h5>
</ol>

<hr>
<a name="zero"><b>0. 요청과 응답으로 엔티티(Entity) 대신 DTO를 사용하는 이유에 대해 설명해주세요 </b></a>
<hr>
<ol>
  <li><b>엔티티 내부를 캡슐화 할 수 있다.</b></li>
  <pre>
  엔티티란 도메인의 핵심 로직과 속성을 가지고 있고, 실제 DB의 테이블과 매칭되는 클래스이다.
  그렇기 때문에 엔티티가 getter와 setter를 갖게 된다면, 
  controller와 같은 비즈니스 로직과 크게 상관없는 곳에서 자원의소 속성이 실수로 변경될 수 있다. 
  또한 엔티티를 UI(User Interface)에서 노출하는 것은 테이블 설계를 화면에 공개하는 것이기에 보안상으로 좋치않다.
  그렇기에 데이터 전달 역할로 DTO를 사용해야한다.
  </pre>
  
  <li><b>화면에 필요한 데이터를 선별할 수 있다</b></li>
  <pre>
  애플리케이션이 확장되면 엔티티의 크기는 점차 커진다 이때 응답과 요청으로 엔티티를 사용한다면, 
  요청하는 화면에 필요하지않는 속성까지도 함께 보내진다. 
  모든 API 요청과 응답에서 엔티티의 모든 속성이 함께 전송되기 때문에 당연히 속도가 느려진다 
  </pre>
  
  <li><b>순환 참조를 예발할 수 있다</b></li>
  <pre>
  양방향 참조된 엔티티를 컨트롤러에서 응답으로 return하게 되면, 
  엔티티가 참조하고 있는 객체는 지연 로딩되고, 로딩된 객체는 또 다시 본인이 참조하고 있는 객체를 호출하게 된다. 
  이렇게 서로 참조하는 객체를 계속 호출하면서 무한 루프 문제가 발생된다
  이러한 경우 양방향 참조가 부득이한 상황이라면 순환참조가 일어나지 않도록 응답의 return으로 DTO로 두는 것이 더 안전하다
  </pre>
  
  <li><b>validation 코드와 모델링 코드를 분리할 수 있다</b></li>
  <pre>
  엔티티 클래스는 DB의 테이블과 매칭되는 필드과 속성으로 선언되어 있고, 
  복잡한 비즈니스 로직이 작성되어 있는 곳이다. 
  여기에 만약 validation 코드가 들어간다면 엔티티 클래스는 더 복잡해지고 가독성이 저하된다. 
  이러한 경우 validation을 DTO에서 정의한다면 엔티티 클래스를 좀 더 모델링과 비즈니스 로직에만 집중되도록 만들 수 
  </pre>
</ol>
