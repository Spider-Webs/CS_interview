<h2>자바 기술 면접</h2>
<hr>
<ol>
<h5><a href="#zero"><li> Java의 특징을 설명해주세요</li></a></h5>
<h5><a href="#one"><li> 컴파일</li></a></h5>
<h5><a href="#two"><li> String, StringBuffer, StringBuilder의 차이 </li></a></h5>
<h5><a href="#three"><li> 접근제어자에 대해서 설명하세요</li></a></h5>
<h5><a href="#four"><li> OOP(Object Oriented Programming, 객체지향)의 4가지 특징에 대해 설명하시오</li></a></h5>
<h5><a href="#five"><li> OOP의 5대원칙</li></a></h5>
<h5><a href="#six"><li> JVM 에대해 설명하시오</li></a></h5>
<h5><a href="#seven"><li> 클래스 객체 인스턴스 차이</li></a></h5>
<h5><a href="#eight"><li> interface 와 abstract class 차이</li></a></h5>
<h5><a href="#nine"><li>  CheckedException과 UnCheckedException의 차이를 설명해주세요.</li></a></h5>
<h5><a href="#ten"><li>  Call by Reference와 Call by Value의 차이를 설명해주세요.</li></a></h5>
<h5><a href="#oone"><li> 가비지 컬렉션(Garbage Collection)에 대해 설명해주세요. </li></a></h5>
<h5><a href="#otwo"><li> java Map 인터페이스 구현체의 종류에대해 설명해주세요.</li></a></h5>
<h5><a href="#othree"><li>불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요. </li></a></h5>
<h5><a href="#ofour"><li> String이 불변객체인 이유에대해서 설명해주세요 </li></a></h5>
<h5><a href="#ofive"><li>.new String 과 ""(리터럴)의 차이에 대해 설명해주세요 </li></a></h5>
<h5><a href="#osix"><li> 제네릭에 대해 설명해주시고, 왜 쓰는지 알려주세요.  </li></a></h5>
<h5><a href="#oseven"><li> 리플렉션(Reflection)이란 무엇인지 설명해주세요 그리고 어떤 경우에 사용되는지 설명해주세요 </li></a></h5>
<h5><a href="#oeight"><li> ==와 equals()의 차이에 대해 설명해주세요 </li></a></h5>
<h5><a href="#oeight"><li> 프레임워크랑 라이브러리차이에대해 설명해주세요</li></a></h5>
</ol>




<br><br>
<hr>
<a name="zero"><b>0. Java의 특징을 설명해주세요 </b></a>
<hr>
<ul>
  <li>Java는 객체지향 프로그래밍언어입니다 </li>
  <li>기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 추상화, 다형성이 잘 적용된 언어입니다.</li>
  <li>장점</li>
  <ul>
    <li>JVM 위에서 동작하기 때문에 운영체제에 독립적입니다</li>
    <li>GarbageCollector를 통한 자동적인 메모리 관리가 가능합니다</li>
    <li>자바는 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 실행되는 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있습니다 </li>
  </ul>
  <li>단점</li>
  <ul>
    <li>JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느립니다</li>
    <li>다중 상속이나 타입에 엄격하며, 제약이 많습니다</li>
  </ul>
</ul>
<hr>


<a name="one"><b>1. 컴파일</b><br></a>
<hr>
<h4>컴파일 과정</h4>
<ul>
  <li>개발자가 .java파일을 생성하고</li>
  <li>build를 합니다</li>
  <li>java compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성하고</li>
  <li>Class Loader를 통해 JVM메모리 내로 로드합니다 이후</li>
  <li>실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석된다(각 운영체제에 부합하는 기계어)</li>
</ul>
<h5>빌드란?</h5>
<pre>
소스코드 파일을 실행가능한 소프트웨어 결과물로 만드는 일련의 과정
빌드의 단계 중 컴파일이 포함되어있고
빌드 과정을 도와주는 도구를 빌드 툴이라 합니다
빌드 툴이 제공해주는 기능으로는 다음과 같은 기능이 있습니다
<ul>
<li>전처리</li>
<li>컴파일</li>
<li>패키징</li>
<li>테스팅</li>
<li>배포</li>
빌드 툴로는 Ant, Maven, Gradle 등이 있습니다.
</ul>
</pre>

<h5>컴파일이란?</h5>
<pre>
컴퓨터가 이해할 수 있는 기계어로 변환하는 작업입니다. 이러한 작업을 해주는 프로그램을 가르켜 컴파일러(Compiler)라 합니다.
자바의 경우, 자바가상머신(JVM)에서 실행가능한 바이트코드 형태의 클래스파일이 생성이 됩니다.
</pre>
<strong>Tip.</strong>
<h5>Compiler vs Interpreter</h5>
🤚<br>
컴파일러는 전체 소스코드를 보고 명령어를 수집하고 재구성하지만
인터프리터는 소스코드의 각 행을 연속적으로 분석하며 실행합니다.
<br>
🤚 <br>
인터프리터는 고레벨 언어를 바로 기계어로 번역하지 않고 중간 형태로 변환시킨 후 실행합니다.
반면 컴파일러는 고레벨 언어를 바로 기계어로 변환합니다.

<hr>
<a name="two"><b>2. String, StringBuffer, StringBuilder의 차이 </b></a>
<hr>
<ul>
  <li>String은 불변속성이지만, StringBuffer와 StringBuilder는 가변의 속성을 가집니다</li>
  <li>StringBuffer는 동기화를 지원하여 멀티쓰레드 환경에서 주로 사용합니다</li>
  <li>StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용합니다</li>
</ul>
<pre>
String 클래스는 불변하기 때문에 문자열을 수정하는 시점에 <b>새로운 String 인스턴스</b>가 생성됩니다<br>
수정하기 이전 문자열의 경우 할당 되어 있던 메모리영역은 Garbage로 남아 있다가 GC(garbage collection)에 의해 사라집니다
그러므로 변하지 않는 문자열의 경우 String을 사용하면 좋은 성능을 발휘 하지만 추가 삭제 수정등 연산이 빈번할 경우 String 클래스는 힙 메모리에 많은 Garbage가 생성되어 메모리 부족이 발생 됩니다<br>
이를 해결하기 위해 가변성을 가지는 StringBuffer / StringBuilder 클래스가 도입되었으며, 
두 클래스의 가장 큰 차이점은 동기화 유무 입니다. StringBuffer는 동기화를 지원하여 멀티쓰레드 환경에서 안전하며
(String 또한 불변이기에 여러개의 thread가 불변객체에 접근해서 수정하려해도 수정이 불가능하기때문에 멀티쓰레드 환경에서 안정성이 있습니다)
StringBuilder는 동기화를 지원하지않아 멀티쓰레드 환경에서는 적합하지 않지만, 단일쓰레드에서의 성능은 StringBuffer보다 뛰어납니다
</pre>

<hr>
<a name="three"><b>3. 접근제어자에 대해서 설명하세요</b></a>
<hr>
<ul>
  <li>변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미하며, 총 4가지 종류가 있습니다</li>
  <li><b>public</b> - 접근제한이 없습니다. 같은 프로젝트 내 어디서든 사용 가능합니다</li>
  <li><b>protected</b> - 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능합니다</li>
  <li><b>(default는 생략이 가능합니다)</b> - 해당 패키지 내에서만 접근 가능합니다</li>
  <li><b>private</b> - 해당 클래스에서만 접근 가능합니다</li>
</ul>  

<hr>
<a name="four"><b>4. OOP(Object Oriented Programming, 객체지향)의 4가지 특징에 대해 설명하시오</b></a>
<hr>
<ul>
  <li>캡슐화</li>
  <li>상속</li>
  <li>추상화</li>
  <li>다형성</li>
</ul>
<h5>캡슐화</h5>
<pre>
캡슐화의 속성으로는 2가지가 있습니다.

1. 필드와 메소드를 클래스로 묶는 데이터 캡슐화 이고,
2. 외부에서 객체의 데이터를 변경하는것을 막기위한 은닉화(접근제어자, setter, getter의 사용) 입니다

또한 프로그램을 설계 할때 높은 응집도와 낮은 결합도를 유지해야 요구사항을 변경하기 쉬운데, 
캡슐화는 낮은 결합도를 유지할 수 있도록 해주는 객체지향 설계 원리입니다.
<ul>
<li> 결합도 : 어떤 기능을 실행하는 데 다른 클래스나 모듈들에 얼마나 의존적인지를 나타낸다.</li>
<li> 응집도 : 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다.</li>
</ul>
</pre>
<h5>상속</h5>
<pre>
자식 클래스가 부모 클래스를 물려받고 기능을 추가하여 확장하는 개념이며,
자식클래스는 부모 클래스의 속성을 물려받아 재사용함으로써 코드 작성에 드는 시간과 비용을 줄이는 효과가 있습니다.
</pre>
<h5>추상화</h5>
<pre>
구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 것 입니다
대표적인 예로는 추상메서드와, 인터페이스입니다
</pre>
<h5>다형성</h5>
<pre>
서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력이라고 생각합니다.
그 예시로는 오버라이딩, 오버로딩이 있습니다.
오버라이딩(Overriding) 은 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용하는 기술이고,
오버로딩(Overloading) 은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술입니다
</pre>

<hr>
<a name="five"><b>5. OOP의 5대원칙</b></a>
<hr>
"SOLID"원칙
<ul>
  <li><b>SRP</b> - 단일 책임 원칙</li>
  <p>객체는 단 하나의 책임만 가져야 합니다</p>
  <li><b>OCP</b> - 개방-폐쇄 원칙</li>
  <p>기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 합니다</p>
  <li><b>LSP</b> - 리스코프 치환 원칙</li>
  <p>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 합니다<br>
  즉, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 역할을 하는데 문제가 없어야 한다는 의미입니다.
  </p>
  <li><b>ISP</b> - 인터페이스 분리 원칙 </li>
  <p>인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙입니다</p>
  <li><b>DIP</b> - 의존 역전 원칙</li>
  <p>의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것 입니다.</p>
</ul>

<hr>
<a name="six"><b>6. JVM 에대해 설명하시오</b></a>
<hr>
<pre>
JVM 이란?
자바 가상 머신으로 자바 바이트 코드를 실행할 수 있는 주체입니다

운영체제 위에서 동작하는 프로세스로 자바코드를 컴파일해서 얻은 바이트 코드를 
해당 운영체제가 이해 할 수 있는 기계어로 바꿔 실행시켜 주는 역할을 합니다

Java와 OS사이의 중개자 역할 그리고 가장 중요한 메모리 관리 Garbage Collection을 수행합니다

크게 Class Loader, Execution Engine, Garbage Collection, Runtime Data Area 로 나뉩니다
</pre>

<hr>
<a name="seven"><b>7. 클래스 객체 인스턴스 차이</b></a>
<ul>
  <li>클래스</li>
  <ul>
    <li>객체를 만들어 내기 위한 <b>설계도</b> 혹은 틀 이며,</li>
    <li>연관되어 있는 변수와 메서드의 집합</li>
  </ul>
  <li>객체</li>
   <ul>
     <li>소프트웨어 세계 <b>구현할 대상</b></li>
    <li>클래스에 선언된 모양 그대로 생성된 실체</li>
     <li><b>'클래스의 인스턴스'</b> 라고도 부른다</li>
    <li>객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다</li>
    <li>oop의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다</li>
  </ul>
  <li>인스턴스</li>
  <ul>
    <li>설계도를 바탕으로 소프트웨어 세계에 <b>구현된 구체적인 실체</b></li>
    <li>인스턴스는 객체에 포함된다고 볼 수 있다</li>
    <li>oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스'라고 부른다</li>
    <li>추상적인 개념(또는 명세)과 구체적인 객체 사이의 <b>관계</b>에 초점을 맞출 경우에 사용한다</li>
    <li>인스턴스는 어떤 원본(추상적인 개념)으로부터 '생성된 복제본'을 의미한다</li>
  </ul>
</ul>

<hr>
<a name="eight"><b>8. interface 와 abstract class 차이</b></a>
<hr>
<pre>
추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고,
인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말합니다.
공통점

new 연산자로 인스턴스 생성 불가능
사용하기 위해서는 하위 클래스에서 확장/구현 해야 한다.


차이점
인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제함에 있고, 
추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.
추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능하다.
</pre>
</hr>

<hr>
<a name="nine"><b>9.  CheckedException과 UnCheckedException의 차이를 설명해주세요. </b></a>
<hr>
<h5>CheckedException 이란?</h5>
<pre>
실행하기 전에 예측 가능한 예외들을 말하는데, 체크 예외가 발생할 수 있는 메소드를 사용할 경우 
복구가 가능한 예외들이기 때문에 반드시 예외를 처리하는 코드를 작성해야 합니다. 
catch문으로 예외를 잡거나, throws로 예외를 자신을 호출한 클래스로 던지는 방법으로 해결해야 합니다.
</pre>
<h5>UnCheckedException 이란?</h5>
<pre>
실행하고 난 후에 알 수 있는 예외들을 말하는데, 언체크 예외라고 불리는 이유는 명시적으로 예외처리를 강제하지 않기 때문입니다.
언체크 예외는 따로 catch문으로 예외를 잡거나, throws로 선언하지 않아도 됩니다. 
프로그램에 오류가 있을 때 발생하도록 의도된 것입니다.
</pre>

<hr>
<a name="ten"><b>10.  Call by Reference와 Call by Value의 차이를 설명해주세요. </b></a>
<hr>
<ul>
  <li>
    <h5>Call by Reference(참조에 의한 호출)</h5>
    <ul>
     <li>함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성됩니다. </li>
     <li>함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달합니다. (해당 변수를 가리킨다.) </li>
     <li>따라서 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경됩니다. </li>
    </ul>
  </li>
  <li>
    <h5>Call by Value (값에 의한 호출)</h5>
     <ul>
     <li>함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성됩니다. </li>
     <li>함수 호출시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달합니다. </li>
     <li>복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가집니다. </li>
       <li>따라서 함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않습니다.</li>
    </ul>
  </li>  
</ul>  
<h5> 자바의 경우에는 Call by Value 입니다</h5>
<pre>
자바의 기본형의 경우 해당하는 변수의 값을 복사해서 전달합니다  
참조형의 경우에도 주소값을 매개변수로 전달하는 것이 아닌 주소를 가리키는 참조 값을 전달하는 것입니다.
또한 주소값 자체를 복사 없이 인자로 전달하는게 아니라 자기 자신이 갖고 있는 값을 복사해서 전달합니다
그러므로 자바의경우 기본형 변수나 참조형 변수 모두 자기 자신이 갖고 있는 값을 복사해서 전달하기 때문에 Call by Value 입니다.
</pre>


<hr>
<a name="oone"><b>11.  가비지 컬렉션(Garbage Collection)에 대해 설명해주세요. </b></a>
<hr>
<h5>가비지 컬렉션은</h5>
<pre>
JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 
필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법입니다.<br>
가비지 컬렉션의 과정으로는
GC의 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고  
GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 (Stop The World 과정) 
사용하지 않는 메모리를 제거(Mark and Sweep 과정)하고 작업이 재개됩니다.
</pre>

<hr>
<a name="otwo"><b>12. java Map 인터페이스 구현체의 종류에대해 설명해주세요. </b></a>
<hr>

<h5>HashMap</h5>
<ul>
  <li>key와 value에 null을 허용합니다</li>
  <li>동기화를 보장하지 않습니다</li>
</ul>  
  <pre>
  HashMap은 thread-safe하지 않아, 싱글 쓰레드 환경에서 사용하는 게 좋습니다. 
  한편, 동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠릅니다.
  결국 HashTable과 ConcurrentHashMap보다 데이터를 찾는 속도는 빠르지만, 신뢰성과 안정성이 떨어집니다.
  </pre>


<h5>HashTable</h5>
<ul>
  <li>key와 value에 null을 허용하지 않습니다</li>
  <li>동기화를 보장합니다</li>
</ul>  
  <pre>
  HashTable은 thread-safe하기 때문에, 멀티 쓰레드 환경에서 사용할 수 있습니다. 
  HashTable은 데이터를 다루는 메소드에 synchronized 키워드가 붙어 있어 해당 키워드는 메소드를 호출하기 전에 쓰레드간 동기화 락을 겁니다. 
  그래서 멀티 쓰레드 환경에서도 데이터의 무결성을 보장합니다. 그러나, 쓰레드간 동기화 락은 매우 느리게 동작한다는 단점이 있습니다.
  </pre>


<h5>ConcurrentHashMap</h5>
<ul>
  <li>key와 value에 null을 허용하지 않습니다</li>
  <li>동기화를 보장합니다</li>
</ul>  
<pre>
ConcurrentHashMap은 thread-safe하기 때문에, 멀티 쓰레드 환경에서 사용할 수 있다. 
ConcurrentHashMap은 HashMap의 동기화 문제를 보완하기 위해 도입됬습니다. 
동기화 처리를 할 때, 어떤 Entry를 조작하는 경우에 해당 Entry에 대해서만 락을 겁니다. 
그래서 HashTable보다 데이터를 다루는 속도가 빠릅니다. 즉, Entry 아이템별로 락을 걸어 멀티 쓰레드 환경에서의 성능을 향상시킵니다.
</pre>
<p>
한 스레드가 진행 중인 작업을 다른 스레드가 간섭하지 못하도록 막는 것을 '스레드의 동기화(synchronization)'라고 합니다.
</p>  
<h5>thread-safe 란?</h5>
<p>
멀티스레드 프로그래밍에서, 공유 자원(어떤 변수나 객체, 구조체 그리고 함수 등)을 여러 스레드가 동시에 접근해도, 프로그램 실행에 문제가 없는 특징 혹은 상태를 말합니다.
</p>
<h5>Entry란</h5>
<p>
  키와 값으로 구성되는 데이터를 매핑(mapping) 또는 엔트리(entry)라고 기술하고 있습니다.
</p>

<hr>
<a name="othree"><b>13.불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요. </b></a>
<hr>
<ul>
  <li>불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말합니다.</li>
  <li>Java에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고,</li>
  <li>참조 타입일 경우엔 추가적인 작업이 필요합니다.</li>
</ul>  

<h5>참조 타입일 경우 추가적인 작업은 어떤게 있는지 설명해주세요.</h5>
<pre>
참조 타입은 대표적으로 1.객체를 참조할 수도 있고, 2.배열이나 3.List 등을 참조할 수 있습니다.
1. 참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 합니다.
2. 배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 됩니다.
(배열을 그대로 참조하거나, 반환할 경우 외부에서 내부 값을 변경할 수 있음. 때문에 clone을 반환해 외부에서 값 변경하지 못하게 함)
3. 리스트인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사하도록 해야 합니다.
배열과 리스트는 내부를 복사하여 전달하는데, 이를 방어적 복사(defensive-copy)라고 합니다.
</pre>

<h5>불변 객체나 final을 굳이 사용해야 하는 이유가 있을까요?</h5>
<pre>
불변 객체나 final 키워드를 사용해 얻는 이점은 다음과 같습니다.
1. Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
(공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문)
2. 실패 원자적인 메소드를 만들 수 있다.
(어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능
3. 부수효과 피해 오류를 최소화 할 수 있다.
※ 부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상
4. 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.
5. 가비지 컬렉션 성능을 높일 수 있다.
(가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다.)
</pre>

<hr>
<a name="ofour"><b>14. String이 불변객체인 이유에대해서 설명해주세요. </b></a>
<hr>
<ol>
  <li><b> 캐싱 기능에 의한 메모리 절약과 속도 향상</b></li>

<p>
- Java에서 String 객체들은 Heap의 String Pool 이라는 공간에 저장되는데, 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을 수록 상당한 성능 향상을 기대할 수 있다.
  </p>

  <li><b> thread-safe</b></li>
  
<p>
- String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전하다.
  </p>
  <li><b> 보안기능</b></li>
  
<p>
- 중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리하다.
  </p>
</ol>

<hr>
<a name="ofive"><b>15.new String 과 ""(리터럴)의 차이에 대해 설명해주세요 </b></a>
<hr>
<pre>
리터럴을 사용하게 되면 string constant pool 이라는 영역에 존재하게 되고 new를 통해 String을 생성하면 Heap 영역에 존재하게 됩니다
String을 리터럴로 선언할 경우 내부적으로 String의 intern() 메서드가 호출되는데
intern() 메서드는 주어진 문자열이 string constant pool에 존재하는지 검색하고 있다면 
그 주소 값을 반환하고 없다면 string constant pool에 넣고 새로운 주소값을 반환 합니다
</pre>

<hr>
<a name="osix"><b>16. 제네릭에 대해 설명해주시고, 왜 쓰는지 알려주세요. </b></a>
<hr>
<pre>
제네릭은 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미입니다.<br>
사용이유는?
<ul>
<li>제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있습니다.</li>
<li>타입 안정성 제공 합니다 컴파일시에 타입 체크를 하기 때문에 런타임에서 ClassCastException과 같은 UncheckedException을 보장받습니다</li>
<li>실행 시 타입 에러가 나는것보다는 컴파일 시에 에러를 사전에 방지하는 것이 좋습니다. </li>
<li>또 제네릭 코드를 사용하면 타입을 국한하기 때문에 요소를 찾아올 때 타입변환을 할 필요가 없어 프로그램 성능이 향상됩니다</li>
</ul>
</pre>
<hr>
<a name="oseven"><b>17. 리플렉션(Reflection)이란 무엇인지 설명해주세요 그리고 어떤 경우에 사용되는지 설명해주세요 </b></a>
<hr>
<pre>
💡 
리플렉션(Reflection)이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API 입니다.
<br>

💡 
리플렉션을 사용하는 경우는 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 
런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용됩니다.

프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공합니다. intelliJ의 자동완성 기능, 
스프링의 어노테이션이 리플렉션을 이용한 기능이라 할 수 있습니다.
</pre>

<hr>
<a name="oeight"><b>18. ==와 equals()의 차이에 대해 설명해주세요</b></a>
<hr>
<ul>
<li>
"=="
<ul>
<li>항등 연산자 입니다</li>
<li>참조 비교를 합니다. 두 객체가 같은 메모리 공간을 가리키는지 확인 합니다</li>
<li>모든 기본 유형에 대해 적용 할 수 있습니다</li>
</ul>
</li>
<li>
"equals()"
<ul>
<li>객체 비교 메서드이다</li>
<li>내용 비교를 합니다. 두 객체의 값이 같은지 확인합니다. 즉 문자열의 데이터/내용을 기반으로 비교합니다</li>
<li>기본 유형에 대해서는 적용 할 수 없습니다</li>
</ul>
</li>
</ul>

<hr>
<a name="onine"><b>19.프레임워크랑 라이브러리차이에대해 설명해주세요</b></a>
<hr>
<h5>프레임워크란 </h5>
<pre>
프레임워크는 뼈대나 기반구조를 뜻하고, 제어의 역전 개념이 적용된 대표적인 기술입니다.  
소프트웨어에서의 프레임워크는 '소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합' 이라 할 수 있으며, 
완성된 어플리케이션이 아닌 프로그래머가 완성시키는 작업을 해야합니다. 
객체 지향 개발을 하게 되면서 통합성, 일관성의 부족이 발생되는 문제를 해결할 방법중 하나라고 할 수 있습니다. 
</pre>

<h5>라이브러리란</h5>
<pre>
라이브러리는 단순 활용가능한 도구들의 집합을 말합니다.
즉, 개발자가 만든 클래스에서 호출하여 사용, 클래스들의 나열로 필요한 클래스를 불러서 사용하는 방식을 취하고 있습니다. 
</pre>

<h5>프레임워크와 라이브러리의 차이점</h5>
<pre>
라이브러리와 프레임워크의 차이는 제어 흐름에 대한 주도성이 누구에게/어디에 있는가에 있습니다.
즉, 어플리케이션의 Flow(흐름)를 누가 쥐고 있느냐에 달려 있습니다.
프레임워크는 전체적인 흐름을 스스로가 쥐고 있으며 사용자는 그 안에서 필요한 코드를 짜 넣으며 
반면에 라이브러리는 사용자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓰는 것이라고 할 수 있습니다.
다시 말해, 라이브러리는 라이브러리를 가져다가 사용하고 호출하는 측에 전적으로 주도성이 있으며 
프레임워크는 그 틀안에 이미 제어 흐름에 대한 주도성이 내재(내포)하고 있습니다.
프레임워크는 가져다가 사용한다기보다는 거기에 들어가서 사용한다는 느낌/관점으로 접근할 수 있습니다.
</pre>

<h5>API 란?</h5>
<pre>
API(Application Programming Interface)
○ 직역하자만 응용 프로그램을 만드는데 사용되는 interface이다.  
여기서 interface란 사물간, 사람간, 또는 사람과 사물간에 상호작용을 할 수 있도록 연결해주는 장치, 방법, 형식, 공간 등을 통칭한다
○ Application Programming Interface 즉, API는 응용 프로그램을 만드는데 필요한 연결 장치, 매개체라고 할 수 있다. 
이러한 연결 장치, 매개체가 필요한 이유는, 실제 개발을 할 때 혼자 모든 것을 개발할 수는 없기 때문이다.
○ 예를 들어 우리가 웹 페이지에 경고창을 띄우려고 한다면, 'alert()'를 호출해 사용한다. 
이때 우리가 경고창을 한번 띄울때마다, 'alert()'와 동일한 동작을 하는 코드를 모두 작성하는 것을 생각해보라. 
정말 끔찍한 일이 아닐 수 없다.  그래서 우리는 API를 사용하는 것이다. 여기서 'alert()'도 API 중 하나이다. 
○ 라이브러리와 API를 혼동하지 않도록 주의하자! 실제 개발을 할 때는 여러 컴포넌트를 합쳐서 개발을 하게 되고, 각각의 컴포넌트들은 API를 가지고 있습니다.
이때 많은 컴포넌트들이 라이브러리의 형태로 제공되기 때문에 API와 라이브러리는 혼동할 수 있다. 
하지만, 라이브러리는 컴포넌트 자체를 의미하고, API는 그 컴포넌트를 활용하기 위한 규약이다. 
</pre>


<hr>
<h2>참조</h2>
<h3><a href="https://www.youtube.com/channel/UCHFz--glnVVP1xBLA-8kltg">인큐티비 - 유튜브</a>
<h3><a href="https://dev-coco.tistory.com">슬기로운 개발 생활 - 블로그</a></h3>
<h3><a href="https://velog.io/@sungsuzi/oop%EC%9D%98-4%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95">suzi_911.log - 블로그</a></h3>
<h3><a href="https://jackjeong.tistory.com/">잭코딩 - 블로그</a></h3>
 <h3><a href="https://webclub.tistory.com/">webclub - 블로그</a></h3>

  

